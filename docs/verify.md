# 分布式中的Nginx验证

动态生成Nginx配置之后，此时新生成的配置尚未生效。 只有明确调用`nginx -s reload`之后，此部分配置才会生效。但基于nginx的运行特性(`nginx -s reload`失败后，所有worker都会失败)，所以需要在`reload`之前需要`-t`来确保参数正确。

在分布式环境中，会同时运行多个`nginx`实例，为了提高运行效率，可以使用下面的方案来实现`校验`和`生效`的自动化。

### 分布式方案

从逻辑上，将分布式nginx生效分为两个阶段:

- 验证
- 加载生效

这两个阶段分别在不同的nginx实例上面执行，部署方式如下:

```
                                               + Runtime 运行Nginx集群 +
        +----------+                         +--------------+
        |Verify 验证|                 |------>|   Nginx 1    |<----------------|
    ①  |          |---------------->|       +--------------+                 |
        |  Nginx   |                 |                                        |
        +----------+                 |       +--------------+                 |
                                 ②  |------>|   Nginx 2    |<----------------|<---------真实流量---------LB
                                     |       +--------------+                 |
                                     |                                        |
                                     |       +--------------+                 |
                                     |------>|   Nginx N    |<----------------|
                                     |       +--------------+                 |
```

* 验证

验证阶段在① `Verify Nginx`处执行。验证Nginx的特点是: 1. 不接收任何真实流量， 2. 只负责验证配置文件合法性(执行`nginx -t`)。 3. 所有配置文件和`Runtime Nginx`保持一致性。

`Verify Nginx`所持有的配置文件和后面`Runtime Nginx`的配置文件完全相同，因此在此处验证成功的Nginx在`Runtime Nginx`一定也会成功。

结合[修改原理](modify.md)里面的内容，可以得知动态修改也是在此处执行的。 在`Verify Nginx`中，会部署一个服务来执行动态修改。 当修改完成后，会调用`nginx -t`来验证所生成的配置文件是否正确。如果正确则进入下一阶段。

* 加载生效

`Verify Nginx`将验证通过的所有配置文件打包发送给`Runtime Nginx`。 同样在`Runtime Nginx`中每个实例也有一个sidecar服务，此服务用来接收`Verify Nginx`发来的配置文件，并执行`Nginx -t`和`Nginx -s reload`。此阶段是否需要执行`nginx -t `是有争议的， 如果可以严格保证`Verify Nginx`和`Runtime Nginx`之间的数据一致，此处的验证就是多余的。 但如果为了多加一道保险，不妨再多执行一次(相应的也需要增加失败后的容错逻辑)。从实际运行效果来看，在没有人工干预的情况下，`Verify Nginx`和`Runtime Nginx`的幂等性可以达到90%。

`Runtime Nginx`中的实例采用滚动升级的方式来逐个加载生效，`Verify Nginx`来控制升级顺序。控制逻辑如下:

1. `Verify Nginx`调用`Runtime Nginx`实例的数据同步API，将最新的配置文件打包发送给实例。
2. 实例解压并覆盖当前配置文件，而后调用`nginx -t`执行验证
3. 实例内部验证成功，调用`nginx -s reload`加载生效。

重复调用上述三个步骤，直到所有实例都完成配置同步。

### 方案优缺点

每个方案都不是完美的，或多或少都有不完美的地方。 此方案的优点在于：

1. 依赖少(不依赖后端存储)
2. 易回滚(当出现异常情况后，可以使用上一版的配置文件快速回滚)
3. 易扩展(`Runtime Nginx`所有实例都相互隔离且幂等。 只要在`Verify Nginx`中修改实例地址就完成了扩容和缩容)

而缺点在于:

1. 高频修改时易出错

每次修改和验证都是通过文件来控制，当出现高频修改时，在`Verify Nginx`端可能出现验证和打包时配置文件不对等的情况。 即当验证通过后，又出现修改的情况，此时可能就会将未将验证的配置文件打包发送给`Runtime Nginx`集群。所以高频修改时需要严格控制操作时序(在线上实际运行中，通过消息队列来保证串行处理)

2. 单点隐患

上述方案中`Verify Nginx`形成了逻辑单点。 为了保证所有nginx都使用相同的配置文件，`Verfify Nginx`必须是单实例，因此一旦此实例出现崩溃或者其他异常造成服务不可用，将导致动态修改失效。

3. 容错处理

若能保证`Runtime Nginx`不会出现人为修改，则需要重点考虑`Verify Nginx`的容错处理。 因为文件的特性(容易生成但修改困难)，当配置文件生成后，再单独修改文件中某行内容就会变得很困难。所以当`nginx -t`失败后，只能整体回滚到上个版本。 同批次修改的内容，也不会生效，失败后的代价比较高。


和其它方案，例如openrestry或者使用DB作为后端存储的方案相比，此方案属于一种轻量级的Nginx动态维护方案，适合于中低频修改和配置规则相对简单的场景。